/*
 * de.xwic.appkit.core.model.impl.AbstractHibernateDAOProvider
 * Created on 05.04.2005
 *
 */
package de.xwic.appkit.core.dao.impl.mongo;

import com.mongodb.MongoClient;
import de.xwic.appkit.core.config.ConfigurationManager;
import de.xwic.appkit.core.config.model.EntityDescriptor;
import de.xwic.appkit.core.config.model.Model;
import de.xwic.appkit.core.config.model.Property;
import de.xwic.appkit.core.dao.*;
import de.xwic.appkit.core.dao.impl.hbn.PropertyResolver;
import de.xwic.appkit.core.model.entities.IPicklistText;
import de.xwic.appkit.core.model.queries.PropertyQuery;
import de.xwic.appkit.core.model.queries.resolver.mongo.MongoQueryResolver;
import de.xwic.appkit.core.model.util.EntityUtil;
import de.xwic.appkit.core.trace.ITraceOperation;
import de.xwic.appkit.core.trace.Trace;
import org.mongodb.morphia.AdvancedDatastore;
import org.mongodb.morphia.Key;
import org.mongodb.morphia.query.Query;

import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.util.*;

/**
 * Base implementation of a DAOProvider that is using hibernate.
 *
 * @author Florian Lippisch
 */
public class MongoDAOProviderAPI implements DAOProviderAPI {

    /**
     * active hibernate mongoClient
     */
    private MongoClient mongoClient;
    /**
     * parent provider
     */
    private MongoDAOProvider provider;

    /**
     * Constructor.
     *
     * @param provider    mongo dao provider
     * @param mongoClient client connection
     */
    public MongoDAOProviderAPI(MongoDAOProvider provider, MongoClient mongoClient) {
        this.provider = provider;
        this.mongoClient = mongoClient;
    }

    /**
     * (non-Javadoc)
     *
     * @see de.xwic.appkit.core.dao.DAOProvider#getEntity(int)
     */
    public IEntity getEntity(Class<? extends Object> clazz, int id) throws DataAccessException {
        AdvancedDatastore datastore = MongoUtil.getDatastore(clazz, mongoClient);
        Query<EntityWrapper> entityWrappers = datastore.find(EntityUtil.type(clazz).getName(), EntityWrapper.class, "_id", id, 0, 1);
        IEntityWrapper iEntityWrapper = entityWrappers.get();
        if (iEntityWrapper == null) return null;
        return iEntityWrapper.getEntity();

    }

    /* (non-Javadoc)
     * @see de.xwic.appkit.core.dao.DAOProvider#remove(de.xwic.appkit.core.dao.IEntity)
     */
    public void delete(IEntity entity) throws DataAccessException {
        //System.out.println("DELETE " + entity + " #" + entity.getId() + " - ver: " + entity.getVersion());

        AdvancedDatastore datastore = MongoUtil.getDatastore(EntityWrapper.class, mongoClient);
        EntityWrapper<IEntity> entityWrapper = new EntityWrapper<IEntity>(datastore);
        entityWrapper.setId(entity.getId());
        entityWrapper.setEntity(entity);
        datastore.delete(EntityUtil.type(entity.getClass()).getName(), EntityWrapper.class, entityWrapper.getId());
    }

    /* (non-Javadoc)
     * @see de.xwic.appkit.core.dao.DAOProvider#update(de.xwic.appkit.core.dao.IEntity)
     */
    public void update(IEntity entity) throws DataAccessException {

       /* IUser user = DAOSystem.getSecurityManager().getCurrentUser();
        String userName = "<no-user>";
        if (user != null) {
            // FLI: always use logon name now, as its the unique identifier.
            userName = user.getLogonName(); // user.getName() == null ? user.getLogonName() : user.getName();
        }
*/

        //set the common properties before saving the object again or at first time
        Entity e = (Entity) entity;
        Date date = new Date();

        //history is always new, so ignore these objects
        if (e.getId() == 0 && (!(entity instanceof IHistory))) {
            //if it is new, set these properties...
            e.setCreatedAt(date);
            //  e.setCreatedFrom(userName);
        }

        //more common properties... 
        e.setLastModifiedAt(date);
        //    e.setLastModifiedFrom(userName);

//        try {
//        	throw new RuntimeException("saveOrUpdate: " + e.getClass().getName());
//        } catch (Exception ex) {
//        	ex.printStackTrace();
//        }
        AdvancedDatastore datastore = MongoUtil.getDatastore(e.getClass(), mongoClient);
        EntityWrapper<IEntity> entityWrapper = new EntityWrapper<IEntity>(datastore);
        entityWrapper.setId(e.getId());
        entityWrapper.setEntity(e);

        Key<EntityWrapper<IEntity>> entityWrapperKey = datastore.save(EntityUtil.type(e.getClass()).getName(), entityWrapper);
        // set autogenerated id back to entity
        e.setId(Integer.valueOf(String.valueOf(entityWrapperKey.getId())));
    }

    /* (non-Javadoc)
     * @see de.xwic.appkit.core.dao.DAOProvider#getEntities(de.xwic.appkit.core.dao.Limit)
     */
    public EntityList getEntities(Class<? extends Object> clazz, Limit limit) {
        return getEntities(clazz, limit, null);
    }

    public Query getQuery(Class<? extends Object> clazz, EntityQuery query) {
        Query q;
        IEntityQueryResolver resolver = null;
        if (query != null) {
            resolver = provider.getResolver(query.getClass());
            Object result = resolver.resolve(clazz, query, false);
            if (result instanceof Query) {
                q = (Query) result;
            } else {
                throw new IllegalArgumentException("Resolver class " + resolver.getClass() + " not supported");
            }
        } else {
            q = MongoUtil.createQuery(clazz);
        }

        return q;
    }


    /* (non-Javadoc)
     * @see de.xwic.appkit.core.dao.DAOProvider#getEntities(de.xwic.appkit.core.dao.Limit, de.xwic.appkit.core.dao.EntityFilter)
     */
    @SuppressWarnings("unchecked")
    public EntityList getEntities(Class<? extends Object> clazz, Limit limit, EntityQuery query) {

        ITraceOperation traceOp = null;
        if (Trace.isEnabled()) {
            traceOp = Trace.startOperation(DAO.TRACE_CAT);

        }
        try {
            Query q = new MongoQueryResolver().resolve(clazz, query, false);

            if (limit != null) {
                q.offset(limit.startNo);
                if (limit.maxResults != 0) {
                    q.limit(limit.maxResults);
                }
            }

            if (traceOp != null) {
                traceOp.setInfo("getEntities ('" + clazz.getName() + "', " + limit + ", '" + q.toString() + "')");
            }

            List<Object> result = q.asList();

            List<String> columns = query != null ? query.getColumns() : null;
            //TODO add column support
           /* if (columns != null) {
                result = resolveColumns(result, query);
            }*/

            int count = result.size();
            if (limit != null && result.size() != 0) {
                Object obj = q.countAll();

                if (obj instanceof Integer) {
                    count = ((Integer) obj).intValue();
                } else if (obj instanceof Long) {
                    count = ((Long) obj).intValue();
                } else {
                    throw new RuntimeException("The requested object type for count request is NOT long or int! Please check " + getClass().getName());
                }
            }

            // check that entity is returned and not arrays: use first object in array
            // if query null assume entity check, FIXME might break existing logic
            if ((query == null || query.isReturnEntity()) && result.size() > 0) {
                Object obj = result.get(0);
                if (obj != null && obj.getClass().isArray()) {
                    for (int i = 0; i < result.size(); i++) {
                        Object[] obj_array = (Object[]) result.get(i);
                        obj = null;
                        if (obj_array != null && obj_array.length > 0) {
                            obj = obj_array[0];
                        }
                        result.set(i, obj);
                    }
                }
            }

            List<IEntity> entities = new ArrayList<IEntity>(count);
            for (Object entityWrapperObj : result) {
                IEntity entity = ((EntityWrapper) entityWrapperObj).getEntity();
                entities.add(entity);
            }
            return new EntityList(entities, limit, count);
        } finally {
            if (traceOp != null) {
                traceOp.finished();
            }
        }
    }

    /* (non-Javadoc)
     * @see de.xwic.appkit.core.dao.DAOProviderAPI#getCollectionProperty(java.lang.Class, int, java.lang.String)
     */
    @Override
    public Collection<?> getCollectionProperty(Class<? extends IEntity> entityImplClass, int entityId, String propertyId) {
        return null;
    }

    /**
     * @param result
     * @param query
     * @return
     */
    private List<Object> resolveColumns(List<Object> result, EntityQuery query) {

        if (result.size() == 0) {
            return result;
        }

        Object obj = result.get(0);
        if (!(obj instanceof IEntity)) {
            return result;
        }

        List<String> cols = query.getColumns();
        List<Object> rows = new ArrayList<Object>(result.size());
        PropertyResolver[] resolver = new PropertyResolver[cols.size()];
        for (int i = 0; i < cols.size(); i++) {
            resolver[i] = new PropertyResolver(cols.get(i));
        }
        int colSize = cols.size();
        for (Object aResult : result) {
            IEntity entity = (IEntity) aResult;
            Object[] row = new Object[cols.size() + 1];
            row[0] = entity.getId();
            for (int i = 0; i < colSize; i++) {
                Object data = resolver[i].getData(entity);
                row[i + 1] = data;
            }
            rows.add(row);
        }

        return rows;
    }

    /* (non-Javadoc)
     * @see de.xwic.appkit.core.dao.DAOProviderAPI#softDelete(de.xwic.appkit.core.dao.IEntity)
     */
    @SuppressWarnings("unchecked")
    public void softDelete(IEntity entity) throws DataAccessException {

        // build a list of possible references
        List<Property> refList = new ArrayList<Property>();
        Set<Object> toDelete = new HashSet<Object>();
        toDelete.add(new EntityKey(entity));

        Class<? extends IEntity> type = entity.type();
        List<Model> models = ConfigurationManager.getSetup().getModels();
        for (Iterator<Model> itM = models.iterator(); itM.hasNext(); ) {
            Model model = itM.next();
            for (Iterator<String> itE = model.getManagedEntities().iterator(); itE.hasNext(); ) {
                String entityType = itE.next();
                if (!entityType.equals(IPicklistText.class.getName())) {
                    EntityDescriptor descr = model.getEntityDescriptor(entityType);
                    if (!descr.isHidden()) {
                        for (Iterator<Property> itP = descr.getProperties().values().iterator(); itP.hasNext(); ) {
                            Property prop = itP.next();
                            if (prop.getDescriptor().getPropertyType().equals(type) &&
                                    prop.getOnRefDeletion() != Property.IGNORE) {
                                refList.add(prop);
                            }
                        }
                    }
                }
            }
        }

        List<String> badRefList = new ArrayList<String>();

        Integer intEntityId = new Integer(entity.getId());
        // iterate through references (and check them)
        for (Iterator<Property> it = refList.iterator(); it.hasNext(); ) {
            Property prop = it.next();
            // must get the right DAO to query
            DAO dao = DAOSystem.findDAOforEntity(prop.getEntityDescriptor().getClassname());
            PropertyQuery query = new PropertyQuery();
            query.addEquals(prop.getName(), intEntityId);

            List<IEntity> result = dao.getEntities(null, query, false);

            // handle results
            for (Iterator<IEntity> itR = result.iterator(); itR.hasNext(); ) {
                IEntity refE = (IEntity) itR.next();

                String info = prop.getEntityDescriptor().getClassname() + ";" + prop.getName() + ";" + refE.getId() + ";" + dao.buildTitle(refE);
                switch (prop.getOnRefDeletion()) {
                    case Property.DENY: {
                        if (!toDelete.contains(new EntityKey(refE))) {
                            // add if the entity is not already in the list of entities to be deleted.
                            badRefList.add(info);
                        }
                        break;
                    }
                    case Property.DELETE: {
                        if (badRefList.size() == 0) {
                            try {
                                dao.softDelete(refE);
                                toDelete.add(refE);
                            } catch (DataAccessException dae) {
                                if (dae.getMessage().equals("softdelete.hasref")) {
                                    badRefList.addAll((Collection<? extends String>) dae.getInfo());
                                    badRefList.add(info);
                                } else {
                                    throw dae;
                                }
                            }
                        }
                        break;
                    }
                    case Property.CLEAR_REFERENCE: {
                        if (badRefList.size() == 0 && !toDelete.contains(new EntityKey(refE))) {
                            try {
                                PropertyDescriptor propDesc = new PropertyDescriptor(prop.getName(), refE.getClass());
                                Method mWrite = propDesc.getWriteMethod();
                                mWrite.invoke(refE, new Object[]{null});
                                dao.update(refE);
                            } catch (Exception e) {
                                badRefList.add(info);
                            }
                        }
                        break;
                    }
                }

            }

        }

        if (badRefList.size() > 0) {
            DataAccessException dae = new DataAccessException("softdelete.hasref");
            dae.setInfo(badRefList);
            throw dae;
        }

        // now modify the entity using its DAO to make sure that
        // history informations are logged when changing the entity.

        DAO myDao = DAOSystem.findDAOforEntity(type);
        Entity e = (Entity) entity;
        e.setDeleted(true);
        e.setLastModifiedAt(new Date());
        myDao.update(e);


    }


}
